{
  "language": "Solidity",
  "sources": {
    "contracts/Escrowdelta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Escrow Contract\n * @dev Gestión de acuerdos entre comprador, vendedor y árbitro.\n *      Nota: Árbitro global definido temporalmente; mejorar para escalabilidad futura.\n */\ncontract Escrowdelta { \n    // Estados posibles del pedido\n    enum State { AWAITING_DELIVERY, DELIVERED, COMPLETE, REFUNDED }\n    // Resoluciones posibles de las disputas\n    enum DisputeAction { RELEASE_FUNDS, REFUND, EXTEND_DEADLINE }\n\n    // Estructura de cada pedido de escrow\n    struct Escrow {\n        address payer;\n        address payee;\n        uint256 amount;\n        uint256 deadline;\n        uint256 safeDeliveryTime;\n        State currentState;\n        bool inDispute;\n    }\n\n    mapping(uint256 => Escrow) public escrows; // Almacena los pedidos por ID\n    mapping(address => uint256[]) public escrowsByPayer;\n    mapping(address => uint256[]) public escrowsByPayee; \n\n\n    uint256 public escrowCount; // Contador para IDs únicos\n    address public globalArbiter; // Árbitro global temporal\n    uint256 public constant SAFE_TIME = 24 * 60 * 60; // Tiempo seguro de 24 horas en segundos\n\n    // Constructor\n    constructor() {\n        globalArbiter = 0x556ffE28AF4661257F299a9a38e81cD937Adbe3f;\n    }\n\n    // Eventos\n    event EscrowCreated(uint256 indexed escrowId, address indexed payer, address indexed payee, uint256 amount, uint256 deadline);\n    event OrderMarkedAsDelivered(uint256 indexed escrowId, address indexed seller);\n    event FundsReleased(uint256 indexed escrowId, address indexed payee, uint256 amount);\n    event FundsRefunded(uint256 indexed escrowId, address indexed payer, uint256 amount);\n    event DisputeInitiated(uint256 indexed escrowId, address indexed initiator);\n    event DeadlineExtended(uint256 indexed escrowId, uint256 newDeadline);\n    event DisputeResolved(uint256 indexed escrowId, address indexed resolver, uint8 action);\n\n    // Modificadores\n    modifier onlyArbiter() {\n    require(msg.sender == globalArbiter, \"Solo el arbitro puede realizar esta accion.\");\n    _;\n    }\n\n    modifier onlyParticipants(uint256 escrowId) {\n    Escrow storage escrow = escrows[escrowId];\n    require(msg.sender == escrow.payer || msg.sender == escrow.payee,\"Solo el comprador o el vendedor pueden ejecutar esta accion.\"\n    );\n    _;\n    }\n\n    modifier onlyPayee(uint256 escrowId) {\n    Escrow storage escrow = escrows[escrowId];\n    require(msg.sender == escrow.payee, \"Solo el vendedor puede ejecutar esta accion.\");\n    _;\n    }\n\n\n\n    // Crear y fondear un nuevo pedido de escrow\n    function createAndDeposit(address _payee, uint256 _deadline) external payable returns (uint256) {\n        require(msg.value > 0, \"El monto debe ser mayor a cero.\");\n        require(block.timestamp < _deadline, \"Fecha limite invalida.\");\n        require(_payee != address(0), \"Direccion del vendedor invalida.\");\n\n        escrowCount++;\n        escrows[escrowCount] = Escrow({\n            payer: msg.sender,\n            payee: _payee,\n            amount: msg.value,\n            deadline: _deadline,\n            safeDeliveryTime: _deadline + SAFE_TIME,\n            currentState: State.AWAITING_DELIVERY,\n            inDispute: false\n        });\n\n        escrowsByPayer[msg.sender].push(escrowCount);\n        escrowsByPayee[_payee].push(escrowCount);\n\n        emit EscrowCreated(escrowCount, msg.sender, _payee, msg.value, _deadline);\n        return escrowCount;\n    }\n\n    // Marcar el producto como enviado\n    function markAsDelivered(uint256 escrowId) external onlyPayee(escrowId) {\n    Escrow storage escrow = escrows[escrowId];\n    require(escrow.currentState == State.AWAITING_DELIVERY, \"El estado del pedido no es para ser enviado\");\n\n    escrow.currentState = State.DELIVERED;    // Cambia el estado a DELIVERED\n    emit OrderMarkedAsDelivered(escrowId, msg.sender); // Opción: Podrías emitir un evento aquí\n    }\n\n    // Libera los fondos al vendedor\n    function _releaseFunds(uint256 escrowId) internal {\n    Escrow storage escrow = escrows[escrowId];  \n    escrow.currentState = State.COMPLETE; // Actualiza el estado a COMPLETE  \n    payable(escrow.payee).transfer(escrow.amount); // Transfiere los fondos al vendedor\n\n    emit FundsReleased(escrowId, escrow.payee, escrow.amount);   // Emite un evento para registrar la acción\n    }\n\n    // Reembolsar los fondos al comprador\n    function _refund(uint256 escrowId) internal {\n    Escrow storage escrow = escrows[escrowId];\n    escrow.currentState = State.REFUNDED; // Actualiza el estado a REFUNDED\n    payable(escrow.payer).transfer(escrow.amount);  // Transfiere los fondos al comprador\n\n    emit FundsRefunded(escrowId, escrow.payer, escrow.amount); // Emite un evento para registrar la acción\n    }\n\n    // Iniciar Disputas por solo los participantes\n    function initiateDispute(uint256 escrowId) external onlyParticipants(escrowId) {\n    Escrow storage escrow = escrows[escrowId];\n    require(escrow.currentState == State.AWAITING_DELIVERY || escrow.currentState == State.DELIVERED, \"Estado no apto para iniciar disputa.\");\n    require(block.timestamp > escrow.deadline,\"No se puede iniciar disputa mientras el plazo este en curso.\");\n    escrow.inDispute = true; // Activa la disputa\n    emit DisputeInitiated(escrowId, msg.sender);  // Emite un evento para registrar la disputa\n    }\n\n    // Extensión del periodo de tiempo de la transacción\n    function extendDeadline(uint256 escrowId, uint256 newDeadline) internal onlyArbiter {\n    Escrow storage escrow = escrows[escrowId];\n    require(escrow.currentState == State.AWAITING_DELIVERY || escrow.currentState == State.DELIVERED, \"Estado no apto para extender el plazo.\");\n    require(newDeadline > escrow.deadline, \"La nueva fecha debe ser mayor al plazo actual.\");\n\n    escrow.deadline = newDeadline;     // Actualiza el plazo\n    emit DeadlineExtended(escrowId, newDeadline);  // Emite un evento para registrar la extensión del plazo\n    }\n\n    //Resolucion de disputas por el arbitro\n\n    function resolveDispute(uint256 escrowId, DisputeAction action, uint256 newDeadline) external onlyArbiter {\n    Escrow storage escrow = escrows[escrowId];\n    require(escrow.inDispute, \"No hay una disputa activa para este pedido.\");\n\n    if (action == DisputeAction.RELEASE_FUNDS) {\n        require(escrow.currentState == State.DELIVERED, \"No se Puede Liberar fondos, No se Envio el Producto\");\n        _releaseFunds(escrowId); //Libera fondos al Vendedor\n    } else if (action == DisputeAction.REFUND) {\n        require(escrow.currentState == State.AWAITING_DELIVERY || escrow.currentState == State.DELIVERED, \"No se Puede Reembolsar, Estado no permitido\");\n        _refund(escrowId); //Reembolsa fondos al Comprador\n    } else if (action == DisputeAction.EXTEND_DEADLINE) {\n        escrow.inDispute = false;\n        extendDeadline(escrowId, newDeadline); //Extiende el periodo de tiempo\n    } else {\n        revert(\"Accion invalida para resolver la disputa.\");\n    }\n    emit DisputeResolved(escrowId, msg.sender, uint8(action));\n    }\n\n\n    // Manejar plazos vencidos\n    function handleDeadline(uint256 escrowId) external onlyParticipants(escrowId) {\n    Escrow storage escrow = escrows[escrowId];\n\n    // Asegurarse de que el pedido no esté en disputa\n    require(!escrow.inDispute, \"El pedido esta en disputa y no puede manejar plazos.\");\n\n    // Caso 1: El comprador ya recibió el producto antes del `deadline`\n    if (block.timestamp <= escrow.deadline && escrow.currentState == State.DELIVERED) {\n    require(msg.sender == escrow.payer, \"Solo el comprador puede liberar los fondos antes del deadline.\");\n    _releaseFunds(escrowId);\n    return;\n    }\n\n\n    // Caso 2: El producto fue enviado, pero el `safeTime` expiró sin disputa\n    if (block.timestamp > escrow.deadline && escrow.currentState == State.DELIVERED) {\n        if (block.timestamp > escrow.safeDeliveryTime) {\n            _releaseFunds(escrowId); // Liberar fondos al vendedor\n        } else {\n            revert(\"Aun en periodo para que el comprador inicie una disputa.\");\n        }\n        return;\n    }\n\n    // Caso 3: El producto no fue enviado antes del `deadline`\n    if (block.timestamp > escrow.deadline && escrow.currentState == State.AWAITING_DELIVERY) {\n        _refund(escrowId); // Reembolsar fondos al comprador\n        return;\n    }\n\n    revert(\"Actualmente no puede ejecutar esta operacion, verifique el estatus de su pedido\");\n    }\n\n    //Obtener los scrow segun el address\n    function getEscrowsByAddress(address user) external view returns (uint256[] memory payerEscrows, uint256[] memory payeeEscrows) {\n    return (escrowsByPayer[user], escrowsByPayee[user]);\n}\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}